# 2022/4/17

## 物品使用引发的正整数危机

今天遇到了一个很有意思的问题，在我们游戏当中，经常会出现使用物品的情况。
假设指令为：

> 使用 物品名\*数量【例如：使用 金币\*10】

我们需要判定金币这个物品，是否在玩家的背包内，以及玩家要使用的数量是否是玩家拥有的。
这时候肯定会有小可爱，这么打 使用 金币\*7.1
没错，我们物品显然都是正整数，常规的判定并不能满足我们的需求，如果不加以限制的话
使用 金币\*-1，会让玩家的金币数量不减反增。
我最开始的思路如下：

```python
num = input()
print("滚，这个数不行") if(num <= 0 or num !=(int(num)) else print("这个行，能处")
```

但是在实际的测试中，我发现，当我输入1.0时，这个数居然被判定为了有效的正整数。这是为什么呢？
查阅资料后得到，Python会非常“友好”的帮你自动进行数据转换，导致了1.0和1在Python中进行比较时，是相等的。
于是有了新的写法：

```python
num = input()
print("滚，这个数不行") if(num <= 0 or len(str(num)) != len(str(int(num)))) else print("这个行，能处")
```

这显然实现了我想要的功能，但是我觉得，太长了，太累赘了，不够美观，于是，我想到了正则表达式，就有了最终写法：

```python
num = input()
print("滚，这个数不行") if(re.search('\D', value) != None) else print("这个行，能处")
```

我们做一个函数，方便调用，这个功能就算是实现了：

```python
def isinteger(value):
  return False if(re.search('\D', value) != None) else True
```

注意：如果你要使用正则表达式的话，需要先`import re`

## 移动与地图的思考

在我设计的文游当中，我们提供四种移动指令

> 东/南/西/北

这是一个非常有意思的功能,我们首先需要设计一下文件的储存格式。
最容易想到的写法就是这种格式的地图储存了：

```json
{
    "东":"1",
    "西":"2",
    "南":"3",
    "北":"4"
}
```

这个解决方法似乎没有问题，但是问题随之而言，这个非常麻烦，意味着当我设计了一张地图的时候，当他的东边是a的时候，他必然要作为a的西边地图出现，这意味着我们每设计一个地图，就需要改动两个地方，非常麻烦。
还有其他非常多麻烦的地方

这时候我想到的解决方案就是，用坐标来解决问题。
我们直接以地图的第一张图为（0，0）建系，那么所有的地图都是可以用这个坐标系来表示的
这样我们只需要记录一下玩家的坐标，就可以根据玩家目前的坐标，轻松的推理出，他下面可以前往的坐标。

这样我们就轻松的实现了移动的功能：(因为大家没有见过一些函数，所以部分函数就不专门展示了，就用注释的形式表达了)

```python
def move(par):
  #获得玩家基础信息
  #计算
  if(par == "东"):new_pos = str(int(player_pos[0])+1) + "_" + player_pos[1]
  if(par == "西"):new_pos = str(int(player_pos[0])-1) + "_" + player_pos[1]
  if(par == "南"):new_pos = player_pos[0] + "_" + str(int(player_pos[1])-1)
  if(par == "北"):new_pos = player_pos[0] + "_" + str(int(player_pos[1])+1)
  #判断目标地图是否存在 
  #写入坐标
  #展示玩家位置
  return
```
